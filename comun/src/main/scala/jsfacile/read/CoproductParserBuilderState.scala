package jsfacile.read

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer

import jsfacile.joint.namedOrdering
import jsfacile.read.CoproductParser.{CpConsideredField, CpFieldInfo, CpProductInfo}

/** This class is used by the code generated by the macros that derive parsers for coproducts. It is not intended to be used by the library user.
 * It is used by said chunks of generated code, which are nothing but parser builders, to accumulate the information about the subtypes of `C` they need later to build the [[CoproductParser]] instance they return.
 * @tparam C the coproduct */
class CoproductParserBuilderState[C] {

	val productFieldsBuilder: mutable.ArrayBuffer[CpFieldInfo] = ArrayBuffer.empty;
	def addProductField(field: CpFieldInfo): Unit = productFieldsBuilder.addOne(field);
	/** @return a sorted array with the [[CpFieldInfo]] instances added with the [[addProductField]] method. The array is sorted by [[CpFieldInfo.name]] because the [[jsfacile.read.CoproductParser]] requires the ordering to narrow the binary-search of the field's info, after the type-discriminator's field has been parsed. */
	def productFields: Array[CpFieldInfo] = productFieldsBuilder.sortInPlace()(namedOrdering[CpFieldInfo]).toArray;

	val consideredFieldsBuilder: mutable.ArrayBuffer[CpConsideredField] = ArrayBuffer.empty;
	def addConsideredField(consideredField: CpConsideredField): Unit = consideredFieldsBuilder.addOne(consideredField);
	def consideredFields: Array[CpConsideredField] = consideredFieldsBuilder.sortInPlace()(namedOrdering).toArray;

	val productsInfoBuilder: mutable.ArrayBuffer[CpProductInfo[C]] = ArrayBuffer.empty;
	var maxNumberOfFields: Int = 0;
	def addProduct(product: CpProductInfo[C]): Unit = {
		productsInfoBuilder.addOne(product)
		if(product.fields.length > maxNumberOfFields) {
			this.maxNumberOfFields = product.fields.length
		}
	}
	def productsInfo: Array[CpProductInfo[C]] = productsInfoBuilder.sortInPlace()(namedOrdering).toArray;
}
